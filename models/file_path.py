content='from typing import Optional\nimport os\nimport re\nfrom pathlib import Path\nfrom dataclasses import dataclass\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass FilePath:\n    original_path: str\n    normalized_path: str\n    is_valid: bool\n    error_message: Optional[str] = None\n\nclass FilePathOperations:\n    INVALID_CHARS_PATTERN = r\'[<>:"|?*]\'\n    MAX_PATH_LENGTH = 255\n\n    @staticmethod\n    def normalize_path(file_path: str) -> FilePath:\n        """\n        Normalizes a file path by removing invalid characters and ensuring proper format.\n        \n        Args:\n            file_path (str): The original file path to normalize\n            \n        Returns:\n            FilePath: Object containing original and normalized paths with validation info\n        """\n        try:\n            # Remove leading/trailing whitespace\n            cleaned_path = file_path.strip()\n            \n            # Basic validation\n            if not cleaned_path:\n                return FilePath(\n                    original_path=file_path,\n                    normalized_path="",\n                    is_valid=False,\n                    error_message="Empty path provided"\n                )\n\n            # Check path length\n            if len(cleaned_path) > FilePathOperations.MAX_PATH_LENGTH:\n                return FilePath(\n                    original_path=file_path,\n                    normalized_path="",\n                    is_valid=False,\n                    error_message=f"Path exceeds maximum length of {FilePathOperations.MAX_PATH_LENGTH} characters"\n                )\n\n            # Remove invalid characters\n            normalized = re.sub(FilePathOperations.INVALID_CHARS_PATTERN, \'_\', cleaned_path)\n            \n            # Convert to proper path format\n            normalized = os.path.normpath(normalized)\n            \n            # Convert backslashes to forward slashes for consistency\n            normalized = normalized.replace(\'\\\\\', \'/\')\n            \n            # Remove multiple consecutive slashes\n            normalized = re.sub(r\'/+\', \'/\', normalized)\n            \n            return FilePath(\n                original_path=file_path,\n                normalized_path=normalized,\n                is_valid=True\n            )\n\n        except Exception as e:\n            logger.error(f"Error normalizing path {file_path}: {str(e)}")\n            return FilePath(\n                original_path=file_path,\n                normalized_path="",\n                is_valid=False,\n                error_message=f"Error processing path: {str(e)}"\n            )\n\n    @staticmethod\n    def validate_path(file_path: str) -> bool:\n        """\n        Validates if a file path is acceptable.\n        \n        Args:\n            file_path (str): The file path to validate\n            \n        Returns:\n            bool: True if path is valid, False otherwise\n        """\n        try:\n            # Check if path is empty or None\n            if not file_path:\n                return False\n\n            # Check path length\n            if len(file_path) > FilePathOperations.MAX_PATH_LENGTH:\n                return False\n\n            # Check for invalid characters\n            if re.search(FilePathOperations.INVALID_CHARS_PATTERN, file_path):\n                return False\n\n            # Try to create Path object to validate format\n            Path(file_path)\n            \n            return True\n\n        except Exception as e:\n            logger.error(f"Error validating path {file_path}: {str(e)}")\n            return False\n\n    @staticmethod\n    def get_path_info(file_path: str) -> dict:\n        """\n        Gets detailed information about a file path.\n        \n        Args:\n            file_path (str): The file path to analyze\n            \n        Returns:\n            dict: Dictionary containing path information\n        """\n        try:\n            path_obj = Path(file_path)\n            return {\n                \'full_path\': str(path_obj.absolute()),\n                \'parent_directory\': str(path_obj.parent),\n                \'filename\': path_obj.name,\n                \'extension\': path_obj.suffix,\n                \'is_absolute\': path_obj.is_absolute(),\n                \'exists\': path_obj.exists(),\n                \'' additional_kwargs={} response_metadata={'id': 'msg_01KdCQ1dHuMwPA6EdkGqsUKU', 'model': 'claude-3-5-sonnet-20241022', 'stop_reason': 'max_tokens', 'stop_sequence': None, 'usage': {'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0, 'input_tokens': 346, 'output_tokens': 1024, 'service_tier': 'standard'}} id='run--cd17376a-c3ac-4a29-8902-c63f0915fa97-0' usage_metadata={'input_tokens': 346, 'output_tokens': 1024, 'total_tokens': 1370, 'input_token_details': {'cache_read': 0, 'cache_creation': 0}}