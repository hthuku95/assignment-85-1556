content='import os\nimport re\nfrom typing import Optional, Tuple\nimport logging\nfrom pathlib import Path\n\nlogger = logging.getLogger(__name__)\n\nclass PathService:\n    def __init__(self):\n        self.forbidden_chars = r\'[<>:"/\\\\|?*]\'\n        self.max_path_length = 255\n        self.max_filename_length = 255\n\n    def sanitize_filename(self, filename: str) -> str:\n        """\n        Sanitizes a filename by removing forbidden characters and applying length limits.\n        \n        Args:\n            filename (str): The original filename to sanitize\n            \n        Returns:\n            str: The sanitized filename\n        """\n        try:\n            # Remove forbidden characters\n            clean_name = re.sub(self.forbidden_chars, \'_\', filename)\n            \n            # Remove leading/trailing spaces and dots\n            clean_name = clean_name.strip(\'. \')\n            \n            # Ensure the filename isn\'t empty after cleaning\n            if not clean_name:\n                clean_name = \'unnamed_file\'\n                \n            # Truncate if too long (preserving extension)\n            name, ext = os.path.splitext(clean_name)\n            if len(clean_name) > self.max_filename_length:\n                max_name_length = self.max_filename_length - len(ext)\n                clean_name = name[:max_name_length] + ext\n                \n            return clean_name\n            \n        except Exception as e:\n            logger.error(f"Error sanitizing filename \'{filename}\': {str(e)}")\n            return \'unnamed_file\'\n\n    def validate_path(self, path: str) -> Tuple[bool, Optional[str]]:\n        """\n        Validates a file path for security and system compatibility.\n        \n        Args:\n            path (str): The path to validate\n            \n        Returns:\n            Tuple[bool, Optional[str]]: (is_valid, error_message)\n        """\n        try:\n            # Check for None or empty path\n            if not path:\n                return False, "Path cannot be empty"\n\n            # Convert to absolute path and normalize\n            abs_path = os.path.abspath(path)\n            \n            # Check path length\n            if len(abs_path) > self.max_path_length:\n                return False, f"Path exceeds maximum length of {self.max_path_length} characters"\n                \n            # Check for directory traversal attempts\n            if \'..\' in path:\n                return False, "Directory traversal not allowed"\n                \n            # Check if path is absolute (platform independent)\n            if os.path.isabs(path):\n                return False, "Absolute paths not allowed"\n                \n            return True, None\n            \n        except Exception as e:\n            logger.error(f"Error validating path \'{path}\': {str(e)}")\n            return False, f"Invalid path: {str(e)}"\n\n    def join_paths(self, *paths: str) -> str:\n        """\n        Safely joins path components.\n        \n        Args:\n            *paths: Variable number of path components\n            \n        Returns:\n            str: Joined path\n        """\n        try:\n            joined_path = os.path.join(*paths)\n            return os.path.normpath(joined_path)\n        except Exception as e:\n            logger.error(f"Error joining paths {paths}: {str(e)}")\n            return \'\'\n\n    def get_relative_path(self, path: str, base_path: str) -> str:\n        """\n        Gets the relative path from base_path to path.\n        \n        Args:\n            path (str): Target path\n            base_path (str): Base path to calculate relative path from\n            \n        Returns:\n            str: Relative path\n        """\n        try:\n            return os.path.relpath(path, base_path)\n        except Exception as e:\n            logger.error(f"Error getting relative path from \'{base_path}\' to \'{path}\': {str(e)}")\n            return \'\'\n\n    def ensure_directory_exists(self, directory_path: str) -> bool:\n        """\n        Ensures a directory exists, creating it if necessary.\n        \n        Args:\n            directory_path (str): Path to the directory' additional_kwargs={} response_metadata={'id': 'msg_01738cFTAoTrELxg2GH3QkmD', 'model': 'claude-3-5-sonnet-20241022', 'stop_reason': 'max_tokens', 'stop_sequence': None, 'usage': {'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0, 'input_tokens': 346, 'output_tokens': 1024, 'service_tier': 'standard'}} id='run--3073b4f5-2d87-4b43-8976-40ed1c8be30e-0' usage_metadata={'input_tokens': 346, 'output_tokens': 1024, 'total_tokens': 1370, 'input_token_details': {'cache_read': 0, 'cache_creation': 0}}